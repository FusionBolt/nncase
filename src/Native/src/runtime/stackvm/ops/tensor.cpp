/* This file is generated by tools/stackvm_gen/IsaGen at 2022/5/14 下午7:10:02 +08:00.
 *
 * Copyright 2019-2021 Canaan Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "../runtime_function.h"
#include <nncase/kernels/stackvm/tensor_ops.h>

using namespace nncase;
using namespace nncase::runtime;
using namespace nncase::runtime::stackvm;

BEGIN_NS_NNCASE_KERNELS_MODULE(stackvm)

result<void> stackvm_runtime_function::visit(const batch_normalization_op_t &op) noexcept {
    try_var(momentum, pop_tensor());
    try_var(epsilon, pop_tensor());
    try_var(input_var, pop_tensor());
    try_var(input_mean, pop_tensor());
    try_var(bias, pop_tensor());
    try_var(scale, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::batch_normalization(input, scale, bias, input_mean, input_var, epsilon, momentum, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const batch_to_space_op_t &op) noexcept {
    try_var(crops, pop_tensor());
    try_var(block_shape, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::batch_to_space(input, block_shape, crops, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const binary_op_t &op) noexcept {
    try_var(rhs, pop_tensor());
    try_var(lhs, pop_tensor());
    tensor output;
    try_(kernels::stackvm::binary(op.binary_op, lhs, rhs, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const broadcast_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::broadcast(input, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const cast_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::cast(op.new_type, input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const celu_op_t &op) noexcept {
    try_var(alpha, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::celu(input, alpha, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const clamp_op_t &op) noexcept {
    try_var(max, pop_tensor());
    try_var(min, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::clamp(input, min, max, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const compare_op_t &op) noexcept {
    try_var(rhs, pop_tensor());
    try_var(lhs, pop_tensor());
    tensor output;
    try_(kernels::stackvm::compare(op.compare_op, lhs, rhs, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const concat_op_t &op) noexcept {
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::concat(input, axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const conv2d_op_t &op) noexcept {
    try_var(fused_clamp, pop_tensor());
    try_var(groups, pop_tensor());
    try_var(dilation, pop_tensor());
    try_var(padding, pop_tensor());
    try_var(stride, pop_tensor());
    try_var(bias, pop_tensor());
    try_var(weights, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::conv2d(op.pad_mode, input, weights, bias, stride, padding, dilation, groups, fused_clamp, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const conv2d_transpose_op_t &op) noexcept {
    try_var(fused_clamp, pop_tensor());
    try_var(groups, pop_tensor());
    try_var(dilation, pop_tensor());
    try_var(output_padding, pop_tensor());
    try_var(padding, pop_tensor());
    try_var(stride, pop_tensor());
    try_var(output_shape, pop_tensor());
    try_var(bias, pop_tensor());
    try_var(weights, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::conv2d_transpose(op.pad_mode, input, weights, bias, output_shape, stride, padding, output_padding, dilation, groups, fused_clamp, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const cum_sum_op_t &op) noexcept {
    try_var(reverse, pop_tensor());
    try_var(exclusive, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::cum_sum(input, axis, exclusive, reverse, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const dequantize_op_t &op) noexcept {
    try_var(dequant_param, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::dequantize(op.target_type, input, dequant_param, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const elu_op_t &op) noexcept {
    try_var(alpha, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::elu(input, alpha, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const expand_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::expand(input, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const flatten_op_t &op) noexcept {
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::flatten(input, axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const gather_op_t &op) noexcept {
    try_var(index, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::gather(input, axis, index, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const gather_nd_op_t &op) noexcept {
    try_var(index, pop_tensor());
    try_var(batch_dims, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::gather_nd(input, batch_dims, index, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const get_item_op_t &op) noexcept {
    try_var(index, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::get_item(input, index, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const hard_sigmoid_op_t &op) noexcept {
    try_var(beta, pop_tensor());
    try_var(alpha, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::hard_sigmoid(input, alpha, beta, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const hard_swish_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::hard_swish(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const hardmax_op_t &op) noexcept {
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::hardmax(input, axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const instance_normalization_op_t &op) noexcept {
    try_var(epsilon, pop_tensor());
    try_var(bias, pop_tensor());
    try_var(scale, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::instance_normalization(input, scale, bias, epsilon, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const l2_normalization_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::l2_normalization(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const leaky_relu_op_t &op) noexcept {
    try_var(alpha, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::leaky_relu(input, alpha, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const log_softmax_op_t &op) noexcept {
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::log_softmax(input, axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const lp_normalization_op_t &op) noexcept {
    try_var(p, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::lp_normalization(input, axis, p, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const lrn_op_t &op) noexcept {
    try_var(size, pop_tensor());
    try_var(bias, pop_tensor());
    try_var(beta, pop_tensor());
    try_var(alpha, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::lrn(input, alpha, beta, bias, size, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const lstm_op_t &op) noexcept {
    try_var(output_size, pop_tensor());
    try_var(input_forget, pop_tensor());
    try_var(hidden_size, pop_tensor());
    try_var(clip, pop_tensor());
    try_var(activation_beta, pop_tensor());
    try_var(activation_alpha, pop_tensor());
    try_var(p, pop_tensor());
    try_var(initial_c, pop_tensor());
    try_var(initial_h, pop_tensor());
    try_var(sequence_lens, pop_tensor());
    try_var(b, pop_tensor());
    try_var(r, pop_tensor());
    try_var(w, pop_tensor());
    try_var(x, pop_tensor());
    tensor output;
    try_(kernels::stackvm::lstm(op.direction, op.layout, op.activations, x, w, r, b, sequence_lens, initial_h, initial_c, p, activation_alpha, activation_beta, clip, hidden_size, input_forget, output_size, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const mat_mul_op_t &op) noexcept {
    try_var(rhs, pop_tensor());
    try_var(lhs, pop_tensor());
    tensor output;
    try_(kernels::stackvm::mat_mul(lhs, rhs, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const normal_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(seed, pop_tensor());
    try_var(scale, pop_tensor());
    try_var(mean, pop_tensor());
    tensor output;
    try_(kernels::stackvm::normal(op.type, mean, scale, seed, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const normal_like_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(seed, pop_tensor());
    try_var(scale, pop_tensor());
    try_var(mean, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::normal_like(op.type, input, mean, scale, seed, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const one_hot_op_t &op) noexcept {
    try_var(off_value, pop_tensor());
    try_var(on_value, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(values, pop_tensor());
    try_var(depth, pop_tensor());
    try_var(indices, pop_tensor());
    tensor output;
    try_(kernels::stackvm::one_hot(op.one_hot_mode, indices, depth, values, axis, on_value, off_value, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const pad_op_t &op) noexcept {
    try_var(value, pop_tensor());
    try_var(pads, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::pad(op.pad_mode, input, pads, value, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const prelu_op_t &op) noexcept {
    try_var(slope, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::prelu(input, slope, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const prod_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::prod(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const quant_param_of_op_t &op) noexcept {
    try_var(bits, pop_tensor());
    try_var(range, pop_tensor());
    tensor output;
    try_(kernels::stackvm::quant_param_of(op.quant_mode, range, bits, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const quantize_op_t &op) noexcept {
    try_var(quant_param, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::quantize(op.target_type, input, quant_param, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const range_op_t &op) noexcept {
    try_var(step, pop_tensor());
    try_var(end, pop_tensor());
    try_var(begin, pop_tensor());
    tensor output;
    try_(kernels::stackvm::range(begin, end, step, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const range_of_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::range_of(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const reduce_op_t &op) noexcept {
    try_var(keep_dims, pop_tensor());
    try_var(init_value, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::reduce(op.reduce_op, input, axis, init_value, keep_dims, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const reduce_arg_op_t &op) noexcept {
    try_var(select_last_index, pop_tensor());
    try_var(keep_dims, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::reduce_arg(op.reduce_arg_op, input, axis, keep_dims, select_last_index, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const reduce_window2d_op_t &op) noexcept {
    try_var(count_include_pad, pop_tensor());
    try_var(ceil_mode, pop_tensor());
    try_var(dilation, pop_tensor());
    try_var(padding, pop_tensor());
    try_var(stride, pop_tensor());
    try_var(filter, pop_tensor());
    try_var(init_value, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::reduce_window2d(op.reduce_op, input, init_value, filter, stride, padding, dilation, ceil_mode, count_include_pad, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const relu_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::relu(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const relu6_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::relu6(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const require_op_t &op) noexcept {
    try_var(value, pop_tensor());
    try_var(predicate, pop_tensor());
    tensor output;
    try_(kernels::stackvm::require(op.message, predicate, value, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const reshape_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::reshape(input, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const resize_image_op_t &op) noexcept {
    try_var(extrapolation_value, pop_tensor());
    try_var(exclude_outside, pop_tensor());
    try_var(cubic_coeff_a, pop_tensor());
    try_var(new_size, pop_tensor());
    try_var(roi, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::resize_image(op.resize_mode, op.transformation_mode, op.nearest_mode, op.is_tfresize, input, roi, new_size, cubic_coeff_a, exclude_outside, extrapolation_value, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const reverse_sequence_op_t &op) noexcept {
    try_var(time_axis, pop_tensor());
    try_var(batch_axis, pop_tensor());
    try_var(seq_lens, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::reverse_sequence(input, seq_lens, batch_axis, time_axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const select_op_t &op) noexcept {
    try_var(false_value, pop_tensor());
    try_var(true_value, pop_tensor());
    try_var(predicate, pop_tensor());
    tensor output;
    try_(kernels::stackvm::select(predicate, true_value, false_value, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const selu_op_t &op) noexcept {
    try_var(gamma, pop_tensor());
    try_var(alpha, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::selu(input, alpha, gamma, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const shape_of_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::shape_of(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const sigmoid_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::sigmoid(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const size_of_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::size_of(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const slice_op_t &op) noexcept {
    try_var(strides, pop_tensor());
    try_var(axes, pop_tensor());
    try_var(ends, pop_tensor());
    try_var(begins, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::slice(input, begins, ends, axes, strides, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const softmax_op_t &op) noexcept {
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::softmax(input, axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const softplus_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::softplus(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const softsign_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::softsign(input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const space_to_batch_op_t &op) noexcept {
    try_var(paddings, pop_tensor());
    try_var(block_shape, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::space_to_batch(input, block_shape, paddings, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const split_op_t &op) noexcept {
    try_var(sections, pop_tensor());
    try_var(axis, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::split(input, axis, sections, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const squeeze_op_t &op) noexcept {
    try_var(dim, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::squeeze(input, dim, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const stack_op_t &op) noexcept {
    try_var(axis, pop_tensor());
    try_var(inputs, pop_tensor());
    tensor output;
    try_(kernels::stackvm::stack(inputs, axis, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const tile_op_t &op) noexcept {
    try_var(repeats, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::tile(input, repeats, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const transpose_op_t &op) noexcept {
    try_var(perm, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::transpose(input, perm, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const unary_op_t &op) noexcept {
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::unary(op.unary_op, input, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const uniform_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(seed, pop_tensor());
    try_var(low, pop_tensor());
    try_var(high, pop_tensor());
    tensor output;
    try_(kernels::stackvm::uniform(op.type, high, low, seed, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const uniform_like_op_t &op) noexcept {
    try_var(shape, pop_tensor());
    try_var(seed, pop_tensor());
    try_var(low, pop_tensor());
    try_var(high, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::uniform_like(op.type, input, high, low, seed, shape, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const unsqueeze_op_t &op) noexcept {
    try_var(dim, pop_tensor());
    try_var(input, pop_tensor());
    tensor output;
    try_(kernels::stackvm::unsqueeze(input, dim, output, module().kernel_context()));
    return ok(output);
}

result<void> stackvm_runtime_function::visit(const where_op_t &op) noexcept {
    try_var(y, pop_tensor());
    try_var(x, pop_tensor());
    try_var(cond, pop_tensor());
    tensor output;
    try_(kernels::stackvm::where(cond, x, y, output, module().kernel_context()));
    return ok(output);
}
}

END_NS_NNCASE_KERNELS_MODULE
